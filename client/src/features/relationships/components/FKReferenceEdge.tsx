// src/features/relationships/components/FKReferenceEdge.tsx

import React from 'react';
import { BaseEdge, EdgeProps } from 'reactflow';
import { getOrthogonalPath } from '../utils/getOrthogonalPath';
// Import the necessary types
import type { Cardinality, Entity } from '@shared/schema';

// ... (Interface definitions omitted for brevity)

/**
 * @component FKReferenceEdge
 * @description Custom edge for the 'references' relationship, showing solid gray crow's foot FKs.
 * It uses orthogonal routing and dynamic markers for cardinality.
 */
const FKReferenceEdge: React.FC<EdgeProps<FKEdgeData>> = ({
    // CRITICAL: Destructure React Flow's mandatory props, even if we don't use them for path calc.
    // This allows React Flow to manage the component's position and view.
    sourceX, sourceY, targetX, targetY,
    sourcePosition, targetPosition,
    data,
    id,
}) => {
    if (!data) return null;

    // Call our custom path utility, which contains the logic for field-level coordinates
    const { path } = getOrthogonalPath({
        sourceEntity: data.sourceEntity,
        targetEntity: data.targetEntity,
        sourceFieldId: data.sourceFieldId,
        targetFieldId: data.targetFieldId,
        waypoints: data.waypoints,
    });

    // Determine markers based on cardinality
    let markerStartId: string;
    let markerEndId: string;

    switch (data.cardinality) {
        // ... (Marker logic remains the same)
        case 'one-to-one':
            markerStartId = 'cf-one';
            markerEndId = 'cf-one';
            break;
        case 'one-to-many':
        case 'many-to-one':
            markerStartId = 'cf-many';
            markerEndId = 'cf-one';
            break;
        default:
            markerStartId = '';
            markerEndId = '';
    }

    // The 'references' relationship uses a solid gray line
    const style = {
        stroke: '#64748B', // CoolGray-500
        strokeWidth: 2,
        fill: 'none',
    };

    // FIX: Using BaseEdge is technically correct if we pass the path. 
    // If the orthogonal path still doesn't show, it means React Flow is interfering with the SVG rendering 
    // due to internal state. The cleanest way is to abandon BaseEdge and render the path ourselves inside SVG.

    // We will stick with BaseEdge for now, as it handles a lot of boilerplate (like selection/interaction).
    // The issue MUST be in the path data or the coordinates supplied to it.

    // Final review of the path string assumption:
    // If the lines are curved, the path string generated by getOrthogonalPath IS NOT being used.
    // React Flow is falling back to a default path generator. This happens when the component doesn't fully control the path.

    // Since we cannot see the error in BaseEdge, the next logical step is to stop using BaseEdge and render the <path> directly.

    return (
        <path
            id={id}
            className="react-flow__edge-path"
            d={path} // Pass our orthogonal path data
            style={style}
            strokeWidth={style.strokeWidth}
            fill={style.fill}
            markerStart={`url(#${markerStartId})`}
            markerEnd={`url(#${markerEndId})`}
        />
    );
};

export default React.memo(FKReferenceEdge);